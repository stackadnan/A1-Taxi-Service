<?php

namespace App\Http\Controllers\Admin\Pricing;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Models\PricingPostcodeCharge;

class PostcodeController extends Controller
{
    public function index(Request $request)
    {
        $q = $request->get('q');
        $items = PricingPostcodeCharge::when($q, function($qbuilder) use ($q) {
            $qbuilder->where('pickup_postcode', 'like', "%$q%")
                     ->orWhere('dropoff_postcode', 'like', "%$q%");
        })->orderBy('id','desc')->paginate(20);

        // If partial requested (ajax tab load), return only the list partial
        if ($request->get('partial') || $request->ajax()) {
            return view('admin.pricing.postcodes._list', compact('items','q'));
        }

        return view('admin.pricing.postcodes.index', compact('items','q'));
    }

    public function create(Request $request)
    {
        // If request is AJAX (modal load), return only the form partial so the modal can inject it
        if ($request->ajax() || $request->get('partial')) {
            return view('admin.pricing.postcodes._modal_form');
        }

        return view('admin.pricing.postcodes.create');
    }

    public function store(Request $request)
    {
        $data = $request->validate([
            'pickup_postcode' => 'required|string|max:20',
            'dropoff_postcode' => 'required|string|max:20',
            'saloon_price' => 'nullable|numeric|min:0',
            'business_price' => 'nullable|numeric|min:0',
            'mpv6_price' => 'nullable|numeric|min:0',
            'mpv8_price' => 'nullable|numeric|min:0',
            'status' => 'required|in:active,inactive'
        ]);

        $created = PricingPostcodeCharge::create($data);

        // Create or update the reversed record (dropoff -> pickup) so both directions exist
        try {
            if (!empty($data['pickup_postcode']) && !empty($data['dropoff_postcode']) && $data['pickup_postcode'] !== $data['dropoff_postcode']) {
                $reverseAttributes = [
                    'pickup_postcode' => $data['dropoff_postcode'],
                    'dropoff_postcode' => $data['pickup_postcode']
                ];

                $reverse = PricingPostcodeCharge::firstOrNew($reverseAttributes);
                $reverse->saloon_price = $data['saloon_price'] ?? null;
                $reverse->business_price = $data['business_price'] ?? null;
                $reverse->mpv6_price = $data['mpv6_price'] ?? null;
                $reverse->mpv8_price = $data['mpv8_price'] ?? null;
                $reverse->status = $data['status'] ?? 'active';
                $reverse->auto_generated = true;
                $reverse->save();
            }
        } catch (\Exception $e) {
            // Log but do not interrupt main flow
            logger()->warning('Failed to create/update reversed postcode charge: ' . $e->getMessage());
        }

        if ($request->ajax() || $request->wantsJson()) {
            return response()->json(["success" => true, "item" => $created], 201);
        }

        return redirect()->route('admin.pricing.postcodes.index')->with('success', 'Postcode charge created');
    }

    public function edit(Request $request, PricingPostcodeCharge $postcode)
    {
        // For modal/AJAX loads return only the form partial
        if ($request->ajax() || $request->get('partial')) {
            return view('admin.pricing.postcodes._modal_form', ['postcode' => $postcode]);
        }

        return view('admin.pricing.postcodes.edit', ['postcode' => $postcode]);
    }

    public function update(Request $request, PricingPostcodeCharge $postcode)
    {
        $data = $request->validate([
            'pickup_postcode' => 'required|string|max:20',
            'dropoff_postcode' => 'required|string|max:20',
            'saloon_price' => 'nullable|numeric|min:0',
            'business_price' => 'nullable|numeric|min:0',
            'mpv6_price' => 'nullable|numeric|min:0',
            'mpv8_price' => 'nullable|numeric|min:0',
            'status' => 'required|in:active,inactive'
        ]);

        $oldPickup = $postcode->getOriginal('pickup_postcode');
        $oldDrop = $postcode->getOriginal('dropoff_postcode');

        $postcode->update($data);

        // Update the reversed postcode charge so it reflects the updates to this entry.
        // If a reverse exists for the old pair, remove it and create/update the new reverse (dropoff -> pickup)
        try {
            if ($oldPickup && $oldDrop) {
                $oldReverse = PricingPostcodeCharge::where('pickup_postcode', $oldDrop)->where('dropoff_postcode', $oldPickup)->first();
                if ($oldReverse) {
                    // If the old reverse was auto-generated by the system, remove and recreate the updated reverse.
                    // If it was manually created/edited by an admin, leave it alone.
                    if ($oldReverse->auto_generated) {
                        $oldReverse->delete();

                        if (!empty($data['pickup_postcode']) && !empty($data['dropoff_postcode']) && $data['pickup_postcode'] !== $data['dropoff_postcode']) {
                            $reverseAttributes = [
                                'pickup_postcode' => $data['dropoff_postcode'],
                                'dropoff_postcode' => $data['pickup_postcode']
                            ];

                            $reverse = PricingPostcodeCharge::firstOrNew($reverseAttributes);
                            $reverse->saloon_price = $data['saloon_price'] ?? null;
                            $reverse->business_price = $data['business_price'] ?? null;
                            $reverse->mpv6_price = $data['mpv6_price'] ?? null;
                            $reverse->mpv8_price = $data['mpv8_price'] ?? null;
                            $reverse->status = $data['status'] ?? 'active';
                            $reverse->auto_generated = true;
                            $reverse->save();
                        }
                    }
                } else {
                    // No old reverse existed â€” create a new reverse if appropriate
                    if (!empty($data['pickup_postcode']) && !empty($data['dropoff_postcode']) && $data['pickup_postcode'] !== $data['dropoff_postcode']) {
                        $reverseAttributes = [
                            'pickup_postcode' => $data['dropoff_postcode'],
                            'dropoff_postcode' => $data['pickup_postcode']
                        ];

                        $reverse = PricingPostcodeCharge::firstOrNew($reverseAttributes);
                        $reverse->saloon_price = $data['saloon_price'] ?? null;
                        $reverse->business_price = $data['business_price'] ?? null;
                        $reverse->mpv6_price = $data['mpv6_price'] ?? null;
                        $reverse->mpv8_price = $data['mpv8_price'] ?? null;
                        $reverse->status = $data['status'] ?? 'active';
                        $reverse->auto_generated = true;
                        $reverse->save();
                    }
                }
            }
        } catch (\Exception $e) {
            logger()->warning('Failed to update reversed postcode charge: ' . $e->getMessage());
        }

        if ($request->ajax() || $request->wantsJson()) {
            return response()->json(['success' => true, 'item' => $postcode], 200);
        }

        return redirect()->route('admin.pricing.postcodes.index')->with('success', 'Postcode charge updated');
    }

    public function destroy(Request $request, PricingPostcodeCharge $postcode)
    {
        $postcode->delete();

        if ($request->ajax() || $request->wantsJson()) {
            return response()->json(['success' => true], 200);
        }

        // If not an AJAX request, return to the Pricing page keeping the postcode tab active
        return redirect()->to(route('admin.pricing.index') . '#postcode')->with('success', 'Postcode charge deleted');
    }
}
